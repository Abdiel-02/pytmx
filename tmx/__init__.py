from typing import Dict, Optional, Tuple, Union
from xml.etree import ElementTree
from .error import TmxFileNotFoundError, TmxParseError
from .base import Color
from .model.cast import Cast
from .model.layer import ImageLayer, Layer, ObjectGroup
from .model.tileset import Tileset
from .util import build

class Tmx:
    '''Read tmx file generated by Tiled'''

    def __init__(self, file: str, path: str):
        self._path = path
        try:
            self._map = ElementTree.parse(file).getroot()
        except FileNotFoundError as ex:
            raise TmxFileNotFoundError(ex.filename)
        except ElementTree.ParseError as ex:
            raise TmxParseError(ex)
    
    @property
    def version(self) -> Optional[str]:
        return self._map.attrib.get("version", None)

    @property
    def tiledversion(self) -> Optional[str]:
        return self._map.attrib.get("tiledversion", None)

    @property
    def width(self) -> Optional[int]:
        return int(self._map.attrib.get("width", None))

    @property
    def height(self) -> Optional[int]:
        return int(self._map.attrib.get("height", None))
    
    @property
    def tilewidth(self) -> Optional[int]:
        return int(self._map.attrib.get("tilewidth", None))
    
    @property
    def tileheight(self) -> Optional[int]:
        return int(self._map.attrib.get("tileheight", None))

    @property
    def renderorder(self) -> str:
        return self._map.attrib.get("renderorder")

    @property
    def infinite(self) -> bool:
        return bool(int(self._map.attrib.get("infinite")))

    @property
    def backgroundcolor(self) -> Optional[Color]:
        return Color(self._map.attrib.get("backgroundcolor")) \
            if self._map.attrib.get("backgroundcolor", None) != None \
            else None

    @property
    def properties(self) -> Optional[Dict[str, str]]:
        return {
            prop.attrib.get("name"):prop.attrib.get("value")
            for prop in self._map.find("properties").iter("property")
        } if self._map.find("properties") != None else None

    def get_tilesets(self) -> Tuple[Tileset]:
        result = [Tileset(data, self._path) for data in self._map.findall("tileset")]
        if len(result) > 0: return tuple(result)
        else: return None

    def get_layers(self) -> Optional[Tuple[Layer]]:
        result = [Layer(data) for data in self._map.findall("layer")]
        if len(result) > 0: return tuple(result)
        else: return None

    def get_objectGroups(self) -> Optional[Tuple[ObjectGroup]]:
        result = [ObjectGroup(data) for data in self._map.findall("objectgroup")]
        if len(result) > 0: return tuple(result)
        else: return None

    def get_imageLayers(self) -> Optional[Tuple[ImageLayer]]:
        result = [ImageLayer(data) for data in self._map.findall("imagelayer")]
        if len(result) > 0: return tuple(result)
        else: return None

    def casting(self, layer: Layer, tilesets: Tuple[Tileset] = None) -> Tuple[Cast]:
        if tilesets:
            return build(layer, tilesets, self.tilewidth, self.tileheight)
        else:
            tilesets = self.get_tilesets()
            return build(layer, tilesets, self.tilewidth, self.tileheight)
    